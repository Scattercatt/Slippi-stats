{"version":3,"file":"SlippiGame.esm.js","sources":["../src/SlippiGame.ts"],"sourcesContent":["import type { StadiumStatsType, StatOptions, StatsType } from \"./stats\";\nimport { TargetBreakComputer } from \"./stats\";\nimport {\n  ActionsComputer,\n  ComboComputer,\n  ConversionComputer,\n  generateOverallStats,\n  InputComputer,\n  Stats,\n  StockComputer,\n} from \"./stats\";\nimport type {\n  EnabledItemType,\n  EventCallbackFunc,\n  FrameEntryType,\n  FramesType,\n  GameEndType,\n  GameStartType,\n  GeckoListType,\n  MetadataType,\n  PlacementType,\n  RollbackFrames,\n} from \"./types\";\nimport { GameMode } from \"./types\";\nimport { extractDistanceInfoFromFrame } from \"./utils/homeRunDistance\";\nimport { SlpParser, SlpParserEvent } from \"./utils/slpParser\";\nimport type { SlpReadInput } from \"./utils/slpReader\";\nimport { closeSlpFile, getGameEnd, getMetadata, iterateEvents, openSlpFile, SlpInputSource } from \"./utils/slpReader\";\n\n/**\n * Slippi Game class that wraps a file\n */\nexport class SlippiGame {\n  private input: SlpReadInput;\n  private metadata: MetadataType | null = null;\n  private finalStats: StatsType | null = null;\n  private parser: SlpParser;\n  private readPosition: number | null = null;\n  private actionsComputer: ActionsComputer = new ActionsComputer();\n  private conversionComputer: ConversionComputer = new ConversionComputer();\n  private comboComputer: ComboComputer = new ComboComputer();\n  private stockComputer: StockComputer = new StockComputer();\n  private inputComputer: InputComputer = new InputComputer();\n  private targetBreakComputer: TargetBreakComputer = new TargetBreakComputer();\n  protected statsComputer: Stats;\n\n  public constructor(input: string | Buffer | ArrayBuffer, opts?: StatOptions) {\n    if (typeof input === \"string\") {\n      this.input = {\n        source: SlpInputSource.FILE,\n        filePath: input,\n      };\n    } else if (input instanceof Buffer) {\n      this.input = {\n        source: SlpInputSource.BUFFER,\n        buffer: input,\n      };\n    } else if (input instanceof ArrayBuffer) {\n      this.input = {\n        source: SlpInputSource.BUFFER,\n        buffer: Buffer.from(input),\n      };\n    } else {\n      throw new Error(\"Cannot create SlippiGame with input of that type\");\n    }\n\n    // Set up stats calculation\n    this.statsComputer = new Stats(opts);\n    this.statsComputer.register(\n      this.actionsComputer,\n      this.comboComputer,\n      this.conversionComputer,\n      this.inputComputer,\n      this.stockComputer,\n      this.targetBreakComputer,\n    );\n\n    this.parser = new SlpParser();\n    this.parser.on(SlpParserEvent.SETTINGS, (settings) => {\n      this.statsComputer.setup(settings);\n    });\n\n    // Use finalized frames for stats computation\n    this.parser.on(SlpParserEvent.FINALIZED_FRAME, (frame: FrameEntryType) => {\n      this.statsComputer.addFrame(frame);\n    });\n  }\n\n  private _process(shouldStop: EventCallbackFunc = () => false): void {\n    if (this.parser.getGameEnd() !== null) {\n      return;\n    }\n    const slpfile = openSlpFile(this.input);\n    // Generate settings from iterating through file\n    this.readPosition = iterateEvents(\n      slpfile,\n      (command, payload) => {\n        if (!payload) {\n          // If payload is falsy, keep iterating. The parser probably just doesn't know\n          // about this command yet\n          return false;\n        }\n        this.parser.handleCommand(command, payload);\n        return shouldStop(command, payload);\n      },\n      this.readPosition,\n    );\n    closeSlpFile(slpfile);\n  }\n\n  /**\n   * Gets the game settings, these are the settings that describe the starting state of\n   * the game such as characters, stage, etc.\n   */\n  public getSettings(): GameStartType | null {\n    // Settings is only complete after post-frame update\n    this._process(() => this.parser.getSettings() !== null);\n    return this.parser.getSettings();\n  }\n\n  public getItems(): EnabledItemType[] | null {\n    this._process();\n    return this.parser.getItems();\n  }\n\n  public getLatestFrame(): FrameEntryType | null {\n    this._process();\n    return this.parser.getLatestFrame();\n  }\n\n  public getGameEnd(options: { skipProcessing?: boolean } = {}): GameEndType | null {\n    if (options?.skipProcessing) {\n      // Read game end block directly\n      const slpfile = openSlpFile(this.input);\n      const gameEnd = getGameEnd(slpfile);\n      closeSlpFile(slpfile);\n      return gameEnd;\n    }\n\n    this._process();\n    return this.parser.getGameEnd();\n  }\n\n  public getFrames(): FramesType {\n    this._process();\n    return this.parser.getFrames();\n  }\n\n  public getRollbackFrames(): RollbackFrames {\n    this._process();\n    return this.parser.getRollbackFrames();\n  }\n\n  public getGeckoList(): GeckoListType | null {\n    this._process(() => this.parser.getGeckoList() !== null);\n    return this.parser.getGeckoList();\n  }\n\n  public getStats(): StatsType | null {\n    if (this.finalStats) {\n      return this.finalStats;\n    }\n\n    this._process();\n\n    const settings = this.parser.getSettings();\n    if (!settings) {\n      return null;\n    }\n\n    // Finish processing if we're not up to date\n    this.statsComputer.process();\n    const inputs = this.inputComputer.fetch();\n    const stocks = this.stockComputer.fetch();\n    const conversions = this.conversionComputer.fetch();\n    const playableFrameCount = this.parser.getPlayableFrameCount();\n    const overall = generateOverallStats({ settings, inputs, conversions, playableFrameCount });\n\n    const gameEnd = this.parser.getGameEnd();\n    const gameComplete = gameEnd !== null;\n\n    const stats: StatsType = {\n      lastFrame: this.parser.getLatestFrameNumber(),\n      playableFrameCount,\n      stocks: stocks,\n      conversions: conversions,\n      combos: this.comboComputer.fetch(),\n      actionCounts: this.actionsComputer.fetch(),\n      overall: overall,\n      gameComplete,\n    };\n\n    if (gameComplete) {\n      // If the game is complete, store a cached version of stats because it should not\n      // change anymore. Ideally the statsCompuer.process and fetch functions would simply do no\n      // work in this case instead but currently the conversions fetch function,\n      // generateOverallStats, and maybe more are doing work on every call.\n      this.finalStats = stats;\n    }\n\n    return stats;\n  }\n\n  public getStadiumStats(): StadiumStatsType | null {\n    this._process();\n\n    const settings = this.parser.getSettings();\n    if (!settings) {\n      return null;\n    }\n\n    const latestFrame = this.parser.getLatestFrame();\n    const players = latestFrame?.players;\n\n    if (!players) {\n      return null;\n    }\n\n    this.statsComputer.process();\n\n    switch (settings.gameMode) {\n      case GameMode.TARGET_TEST:\n        return {\n          type: \"target-test\",\n          targetBreaks: this.targetBreakComputer.fetch(),\n        };\n      case GameMode.HOME_RUN_CONTEST:\n        const distanceInfo = extractDistanceInfoFromFrame(settings, latestFrame);\n        if (!distanceInfo) {\n          return null;\n        }\n\n        return {\n          type: \"home-run-contest\",\n          distance: distanceInfo.distance,\n          units: distanceInfo.units,\n        };\n      default:\n        return null;\n    }\n  }\n\n  public getMetadata(): MetadataType | null {\n    if (this.metadata) {\n      return this.metadata;\n    }\n    const slpfile = openSlpFile(this.input);\n    this.metadata = getMetadata(slpfile);\n    closeSlpFile(slpfile);\n    return this.metadata;\n  }\n\n  public getFilePath(): string | null {\n    if (this.input.source !== SlpInputSource.FILE) {\n      return null;\n    }\n\n    return this.input.filePath ?? null;\n  }\n\n  public getWinners(): PlacementType[] {\n    const gameEnd = this.getGameEnd({ skipProcessing: true });\n    if (!gameEnd) {\n      return [];\n    }\n\n    const placements = gameEnd.placements;\n    const firstPosition = placements.find((placement) => placement?.position === 0);\n    if (!firstPosition) {\n      return [];\n    }\n\n    const settings = this.getSettings();\n    if (settings?.isTeams) {\n      const winningTeam = settings.players.find(({ playerIndex }) => playerIndex === firstPosition.playerIndex)?.teamId;\n      return placements.filter((placement) => {\n        const teamId = settings.players.find(({ playerIndex }) => playerIndex === placement.playerIndex)?.teamId;\n        return teamId === winningTeam;\n      });\n    }\n\n    return [firstPosition];\n  }\n}\n"],"names":["SlippiGame","constructor","input","opts","metadata","finalStats","parser","readPosition","actionsComputer","ActionsComputer","conversionComputer","ConversionComputer","comboComputer","ComboComputer","stockComputer","StockComputer","inputComputer","InputComputer","targetBreakComputer","TargetBreakComputer","statsComputer","source","SlpInputSource","FILE","filePath","Buffer","BUFFER","buffer","ArrayBuffer","from","Error","Stats","register","SlpParser","on","SlpParserEvent","SETTINGS","settings","setup","FINALIZED_FRAME","frame","addFrame","_process","shouldStop","getGameEnd","slpfile","openSlpFile","iterateEvents","command","payload","handleCommand","closeSlpFile","getSettings","getItems","getLatestFrame","options","skipProcessing","gameEnd","getFrames","getRollbackFrames","getGeckoList","getStats","process","inputs","fetch","stocks","conversions","playableFrameCount","getPlayableFrameCount","overall","generateOverallStats","gameComplete","stats","lastFrame","getLatestFrameNumber","combos","actionCounts","getStadiumStats","latestFrame","players","gameMode","GameMode","TARGET_TEST","type","targetBreaks","HOME_RUN_CONTEST","distanceInfo","extractDistanceInfoFromFrame","distance","units","getMetadata","getFilePath","getWinners","placements","firstPosition","find","placement","position","isTeams","winningTeam","playerIndex","teamId","filter"],"mappings":"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"}